from typing import TYPE_CHECKING

from tensortrade.feed.core import Stream
from tensortrade.feed.core.methods import Methods
from tensortrade.feed.core.mixins import DataTypeMixin

if TYPE_CHECKING:
    from tensortrade.feed.api.float.window.ewm import EWM
    from tensortrade.feed.api.float.window.expanding import Expanding
    from tensortrade.feed.api.float.window.rolling import Rolling


@Stream.register_accessor(name="float")
class FloatMethods(Methods):
    if TYPE_CHECKING:
        # --- Arithmetic ---
        def add(self, other: "Stream[float] | float") -> "Stream[float]": ...
        def radd(self, other: "Stream[float] | float") -> "Stream[float]": ...
        def sub(self, other: "Stream[float] | float") -> "Stream[float]": ...
        def rsub(self, other: float) -> "Stream[float]": ...
        def mul(self, other: "Stream[float] | float") -> "Stream[float]": ...
        def rmul(self, other: "Stream[float] | float") -> "Stream[float]": ...
        def div(self, other: "Stream[float] | float") -> "Stream[float]": ...
        def rdiv(self, other: float) -> "Stream[float]": ...
        def abs(self) -> "Stream[float]": ...
        def neg(self) -> "Stream[float]": ...
        def pow(self, power: float) -> "Stream[float]": ...

        # --- Unary math ---
        def ceil(self) -> "Stream[float]": ...
        def floor(self) -> "Stream[float]": ...
        def sqrt(self) -> "Stream[float]": ...
        def square(self) -> "Stream[float]": ...
        def log(self) -> "Stream[float]": ...
        def pct_change(
            self, periods: int = 1, fill_method: str = "pad"
        ) -> "Stream[float]": ...
        def diff(self, periods: int = 1) -> "Stream[float]": ...

        # --- Accumulators ---
        def cumsum(self) -> "Stream[float]": ...
        def cumprod(self) -> "Stream[float]": ...
        def cummin(self, skipna: bool = True) -> "Stream[float]": ...
        def cummax(self, skipna: bool = True) -> "Stream[float]": ...

        # --- Imputation ---
        def fillna(self, fill_value: float = 0.0) -> "Stream[float]": ...
        def ffill(self) -> "Stream[float]": ...

        # --- Ordering ---
        def clamp_min(self, c_min: float) -> "Stream[float]": ...
        def clamp_max(self, c_max: float) -> "Stream[float]": ...
        def clamp(self, c_min: float, c_max: float) -> "Stream[float]": ...
        def min(self, other: "Stream[float]") -> "Stream[float]": ...
        def max(self, other: "Stream[float]") -> "Stream[float]": ...

        # --- Window ---
        def rolling(self, window: int, min_periods: int = 1) -> "Rolling": ...
        def expanding(self, min_periods: int = 1) -> "Expanding": ...
        def ewm(
            self,
            com: float | None = None,
            span: float | None = None,
            halflife: float | None = None,
            alpha: float | None = None,
            min_periods: int = 0,
            adjust: bool = True,
            ignore_na: bool = False,
        ) -> "EWM": ...


@Stream.register_mixin(dtype="float")
class FloatMixin(DataTypeMixin): ...


class Float:
    """A class to register accessor and instance methods."""

    @classmethod
    def register(cls, names: list[str]):
        """A function decorator that adds accessor and instance methods for
        specified data type.

        Parameters
        ----------
        names : `List[str]`
            A list of names used to register the function as a method.

        Returns
        -------
        Callable
            A decorated function.
        """

        def wrapper(func):
            FloatMethods.register_method(func, names)
            FloatMixin.register_method(func, names)
            return func

        return wrapper


from .accumulators import *
from .imputation import *
from .operations import *
from .ordering import *
from .utils import *
from .window import *
